######################
## Two-Phase Commit ##
######################

sort worker
sort coordinator
sort txn

# Associate workers and coordinators with transactions
immutable relation txn_worker(txn, worker)
immutable relation txn_coord(txn, coordinator)

# Each transaction is coordinated by a unique coordinator
axiom txn_coord(T,C1) -> txn_coord(T, C2) -> C1 = C2

# At least one worker/coordinator for each txn
axiom forall T. exists C. txn_coord(T,C)
axiom forall T. exists W. txn_worker(T,W)

# Coord -> Worker
mutable relation send_txn(txn, coordinator, worker)
mutable relation send_commit(txn, coordinator, worker)
mutable relation send_abort(txn, coordinator, worker)

# Worker -> Coord
mutable relation send_success(txn, worker, coordinator)
mutable relation send_failed(txn, worker, coordinator)

# Coord State
mutable relation txn_failed(txn, coordinator, worker)
mutable relation txn_succeed(txn, coordinator, worker)
mutable relation ccommitted(txn, coordinator)
mutable relation caborted(txn, coordinator)

# Worker States
mutable relation wcommitted(txn, worker)
mutable relation waborted(txn, worker)

#######################
#### Initial State ####
#######################

init !send_commit(T,C,W)
init !send_abort(T,C,W)
init !send_txn(T,C,W)

init !send_success(T,W,C)
init !send_failed(T,W,C)

init !txn_failed(T,C,W)
init !txn_succeed(T,C,W)
init !ccommitted(T,C)
init !caborted(T,C)

init !wcommitted(T,W)
init !waborted(T,W)

################################
### Coordinator Transitions ####
################################

# Broadcast transition to new worker
transition coord_broadcast(t: txn, c:coordinator, w:worker)
  modifies send_txn
  txn_coord(t,c)   &
  txn_worker(t,w)  &
  !send_txn(t,c,w) &
  (new(send_txn(T,C,W)) <-> send_txn(T,C,W) | (T = t & C = c & W = w))

# Get response from a worker:
# failed case
transition coord_record_fail(t: txn, c:coordinator, w:worker)
  modifies txn_failed
  send_failed(t,w,c) &
  !txn_failed(t,c,w) &
  (new(txn_failed(T,C,W)) <-> txn_failed(T,C,W) | (T=t & C=c & W=w))

# Get response from a worker:
# success case
transition coord_record_succeed(t: txn, c:coordinator, w:worker)
  modifies txn_succeed
  send_success(t,w,c) &
  !txn_succeed(t,c,w)  &
  (new(txn_succeed(T,C,W)) <-> txn_succeed(T,C,W) | (T=t & C=c & W=w))

# Decide to commit or abort (nondet)
transition coord_decide_commit(t: txn, c:coordinator)
  modifies ccommitted
  (forall W. (!txn_worker(t,W) | txn_succeed(t,c,W) | txn_failed(t,c,W))) &
  !caborted(t,c) &
  !ccommitted(t,c) &
  (new(ccommitted(T,C)) <-> ccommitted(T,C) | (T=t & C=c))

# Decide to commit or abort (nondet)
transition coord_decide_abort(t: txn, c:coordinator)
  modifies caborted
  (forall W. (!txn_worker(t,W) | txn_succeed(t,c,W) | txn_failed(t,c,W))) &
  !caborted(t,c) &
  !ccommitted(t,c) &
  (new(caborted(T,C)) <-> caborted(T,C) | (T=t & C=c))

# Broadcast decision
transition coord_broadcast_abort(t: txn, c:coordinator, w:worker)
  modifies send_abort
  txn_worker(t,w)  &
  caborted(t,c) &
  !send_abort(t,c,w) &
  (new(send_abort(T,C,W)) <-> send_abort(T,C,W) | (T=t & C=c & W=w))

# Broadcast decision
transition coord_broadcast_commit(t: txn, c:coordinator, w:worker)
  modifies send_commit
  txn_worker(t,w)  &
  ccommitted(t,c) &
  !send_commit(t,c,w) &
  (new(send_commit(T,C,W)) <-> send_commit(T,C,W) | (T=t & C=c & W=w))

############################
#### Worker Transitions ####
############################

# Worker receives the transaction, does local work,
# and sends the response (success case)
transition worker_do_txn(t: txn, w: worker, c: coordinator)
  modifies send_success
  send_txn(t,c,w) &
  !send_failed(t,w,c) &
  !send_success(t,w,c) &
  (new(send_success(T,W,C)) <-> send_success(T,W,C) | (T=t & W=w & C=c))

# Worker receives the transaction, does local work,
# and sends the response (failure case)
transition worker_fail_txn(t: txn, w: worker, c: coordinator)
  modifies send_failed
  send_txn(t,c,w) &
  !send_failed(t,w,c) &
  !send_success(t,w,c) &
  (new(send_failed(T,W,C)) <-> send_failed(T,W,C) | (T=t & W=w & C=c))

# Worker receives 'abort' from coordinator
transition worker_receive_abort(t: txn, w: worker, c:coordinator)
  modifies waborted
  send_abort(t,c,w) &
  (new(waborted(T,W)) <-> waborted(T,W) | (T=t & W=w))

# Worker receives 'commit' from coordinator
transition worker_receive_commit(t: txn, w: worker, c:coordinator)
  modifies wcommitted
  send_commit(t,c,w) &
  (new(wcommitted(T,W)) <-> wcommitted(T,W) | (T=t & W=w))

################################
## Property: Worker consensus ##
################################
# The property:
# for all transactions T
# for all pairs of workers W1 and W2, either
# 1. W1 is not finished
# 2. W2 is not finished
# 3. W1 and W2 both aborted
# 3. W1 and W2 both committed
safety !txn_worker(T,W1)                     |
!txn_worker(T,W2)                     |
(!wcommitted(T,W1) & !waborted(T,W1)) |
(!wcommitted(T,W2) & !waborted(T,W2)) |
(wcommitted(T,W1) & wcommitted(T,W2)) |
(waborted(T,W1) & waborted(T,W2))

#####################
## Phase Structure ##
#####################

# The protocol is proved correct by proving non-interference w.r.t.
# the state associated with a particular coordinator & transaction.

# First, we split txn->{qt, qt#} and coordinator{qc, qc#}
immutable constant qt: txn
immutable constant qc: coordinator

# Then, break the protocol into two phases:
# 1. The coordinator of qt, qc, has _not_ yet decided to commit or abort
# 2. qc _has_ decided to commit or abort
automaton {
  init phase executing_txn

  global
    transition coord_broadcast        -> self
    transition coord_record_fail      -> self
    transition coord_record_succeed   -> self
    transition coord_decide_commit    -> self assume !(t=qt & c=qc)
    transition coord_decide_abort     -> self assume !(t=qt & c=qc)
    transition coord_broadcast_abort  -> self
    transition coord_broadcast_commit -> self
    transition worker_do_txn          -> self
    transition worker_fail_txn        -> self
    transition worker_receive_abort   -> self
    transition worker_receive_commit  -> self

  phase executing_txn
    transition coord_decide_commit -> phase done assume (t=qt & c=qc)
    transition coord_decide_abort -> phase done assume (t=qt & c=qc)
    # invariant true

  phase done
    # This invariant suffices for the 'done' phase:
    # when "done" either aborted or committed
    # hold.
    # invariant !(!caborted(qt,qc) & !ccommitted(qt,qc))
}

sat trace {
  coord_broadcast
  coord_broadcast
  worker_do_txn
  worker_do_txn
  coord_record_succeed
  coord_record_succeed
  coord_decide_abort
  coord_broadcast_abort
}

unsat trace {
  coord_broadcast
  coord_broadcast
  worker_do_txn
  worker_do_txn
  coord_record_succeed
  coord_record_succeed
  coord_decide_commit
  coord_broadcast_abort
}
